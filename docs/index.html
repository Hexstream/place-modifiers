<!DOCTYPE html>

<html>

  <head>
    <meta charset="UTF-8" />
    <link rel="canonical" href="https://www.hexstreamsoft.com/libraries/place-modifiers/" />
    <meta name="author" content="Jean-Philippe Paradis" />
    <link rel="author" href="https://abc.hexstream.xyz/" />
    <link rel="license" href="https://www.hexstreamsoft.com/UNLICENSE" />
    <meta name="description" content="Essentially gives access to hundreds of modify-macros through one single macro: modify. Forget nreversef! (modify (nreverse list))" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>place-modifiers | Libraries | HexstreamSoft</title>
    <link rel="stylesheet" type="text/css" href="https://global.hexstream.dev/css/global.css" />
    <link rel="stylesheet" type="text/css" href="https://global.hexstream.dev/css/section-nav.css" />
    <link rel="stylesheet" type="text/css" href="https://global.hexstream.dev/css/tabs.css" />
    <link rel="stylesheet" type="text/css" href="https://global.hexstream.dev/css/tags.css" />
    <link rel="stylesheet" type="text/css" href="https://global.hexstream.dev/css/cl.css" />
    <link rel="stylesheet" type="text/css" href="https://www.hexstreamsoft.com/libraries/libraries.css" />
    <script src="https://global.hexstream.dev/scripts/arrows-madness.mjs" type="module"></script>
    <script src="https://www.hexstreamsoft.com/libraries/libraries.mjs" type="module"></script>
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@HexstreamSoft" />
    <meta name="twitter:title" content="place-modifiers" />
    <meta name="twitter:description" content="Essentially gives access to hundreds of modify-macros through one single macro: MODIFY. (modify (parse-integer place)) == (setf place (parse-integer place))" />
  </head>

  <body>

    <nav id="top-nav">

      <div class="main">

        <div class="breadcrumbs">
          <a href="https://www.hexstreamsoft.com/">HexstreamSoft</a>
          <span class="crumb"><span class="s"> » </span><a href="https://www.hexstreamsoft.com/libraries/">Libraries</a></span>
          <span class="crumb"><span class="s"> » </span><a class="here">place-modifiers</a></span>
        </div>

        <nav class="tabs" id="meta-nav">
          <ul>
            <li><a class="github" href="https://github.com/Hexstream/place-modifiers"><span>See on GitHub</span></a></li>
          </ul>
        </nav>

      </div>

      <p id="last-updated"><span>This page was last updated on </span><time datetime="2018-09-06">6 september 2018</time><span>.</span></p>

    </nav>

    <main>

      <header id="page-header">
        <h1>place-modifiers</h1>
      </header>

      <div class="tags contains-groups">
        <div class="group prominent">
          <span class="tag hv license">
            <span class="h">License<span>:</span></span>
            <span class="v">Public Domain</span>
          </span>
          <span class="s">, </span>
          <span class="tag hv quicklisp">
            <span class="h">Load it with Quicklisp<span>:</span></span>
            <code class="v">(ql:quickload "place-modifiers")</code>
          </span>
        </div>
        <div class="group">
          <span class="tag hv">
            <span class="h">Library type<span>:</span></span>
            <span class="v">Operator overlay macro</span>
          </span>
          <span class="s">, </span>
          <span class="tag hv">
            <span class="h">Project complexity<span>:</span></span>
            <span class="v">Simple/Medium</span>
          </span>
        </div>
      </div>

      <nav class="tabs" id="further-info">
        <ul>
          <li><a href="https://www.hexstreamsoft.com/libraries/releases/latest-versions/#place-modifiers">Latest release</a></li>
          <li><a href="https://www.hexstreamsoft.com/libraries/dependencies/#place-modifiers">Dependencies</a></li>
        </ul>
        <ul>
          <li><a href="https://www.hexstreamsoft.com/libraries/external-pages-xref/#place-modifiers">External library pages</a></li>
        </ul>
      </nav>

      <section id="introduction">

        <p><cite class="common-lisp library">place-modifiers</cite> essentially gives access to hundreds of modify-macros through one single macro: <code class="relevant">modify</code>.</p>

      </section>

      <p class="scroll"><b>To use place-modifiers, simply <code class="common-lisp">(:import-from #:place-modifiers #:modify)</code>. Don't <code>(:use)</code>!</b></p>

      <p>(Things start a bit slowly, but don't worry, it gets more and more interesting!)</p>

      <nav class="tabs">
        <ul>
          <li><a href="#trivial-examples">3 trivial examples</a></li>
          <li><a href="#hundreds-of-modify-macros">Equivalent to hundreds of modify macros!</a></li>
          <li><a href="#why-not-by-hand">Why not just write it out by hand?</a></li>
          <li><a href="#modify-return-values"><code class="relevant">modify</code> return values, <code class="relevant marker">:old</code></a></li>
          <li><a href="#place-modification-expression-vs-place"><abbr title="place-modification-expression">PME</abbr> VS place</a></li>

          <li><a href="#multiple-place-modification-expressions">Multiple <abbr title="place-modification-expression">PME</abbr>s</a></li>
          <li><a href="#place-modifier-variants">Place-modifier variants</a></li>
          <li><a href="#variants-statistics">Some statistics about place-modifier variants</a></li>
        </ul>
      </nav>

      <section id="trivial-examples">

        <h1 class="breadcrumbs-bar">
          <span class="section-relative-nav">
            <a href="#trivial-examples" class="anchor">⚓</a>
          </span>
          <span class="breadcrumbs">
            <a href="#">place-modifiers</a>
            <span class="crumb"><span class="s"> » </span><a class="here">3 trivial examples</a></span>
          </span>
        </h1>

        <div class="scroll">
          <pre class="example"><code class="common-lisp">(let ((<var>place</var> 7))
  (<code class="relevant">modify</code> (<code class="relevant marker">1+</code> <var>place</var>))
  <var>place</var>)
==
(let ((<var>place</var> 7))
  (incf <var>place</var>)
  <var>place</var>)
=&gt; 8</code></pre>
        </div>

        <div class="scroll">
          <pre class="example"><code class="common-lisp">(let ((<var>place</var> '(old)))
  (<code class="relevant">modify</code> (<code class="relevant marker">cons</code> 'new <var>place</var>))
  <var>place</var>)
==
(let ((<var>place</var> '(old)))
  (push 'new <var>place</var>)
  <var>place</var>)
=&gt; (NEW OLD)</code></pre>
        </div>

        <div class="scroll">
          <pre class="example"><code class="common-lisp">;; Reminder for newbies: string-equal is case-insensitive comparison.
(let ((<var>place</var> '(<code class="string">"hello"</code> <code class="string">"hi"</code>)))
  (<code class="relevant">modify</code> (<code class="relevant marker">adjoin</code> <code class="string">"HELLO"</code> <var>place</var> :test #'string-equal))
  <var>place</var>)
==
(let ((<var>place</var> '(<code class="string">"hello"</code> <code class="string">"hi"</code>)))
  (pushnew <code class="string">"HELLO"</code> <var>place</var> :test #'string-equal)
  <var>place</var>)
=&gt; (<code class="string">"hello"</code> <code class="string">"hi"</code>)</code></pre>
        </div>

      </section>

      <section id="hundreds-of-modify-macros">

        <h1 class="breadcrumbs-bar">
          <span class="section-relative-nav">
            <a href="#hundreds-of-modify-macros" class="anchor">⚓</a>
          </span>
          <span class="breadcrumbs">
            <a href="#">place-modifiers</a>
            <span class="crumb"><span class="s"> » </span><a class="here">Equivalent to hundreds of modify macros!</a></span>
          </span>
        </h1>

        <p>Not very exciting so far. But <code>incf</code>, <code>push</code> and <code>pushnew</code> give you access to 3 modify-macros, whereas <code class="relevant">modify</code> gives you access to literally <em>hundreds</em>!</p>

        <div class="scroll">
          <pre class="example"><code class="common-lisp">;; Traditionally "nreversef"
(let ((<var>place</var> (list 1 2 3)))
  (<code class="relevant">modify</code> (<code class="relevant marker">nreverse</code> <var>place</var>))
  <var>place</var>)
=&gt; (3 2 1)</code></pre>
        </div>

        <div class="scroll">
          <pre class="example"><code class="common-lisp">;; "string-upcasef"?...
(let ((<var>place</var> <code class="string">"Yay"</code>))
  (<code class="relevant">modify</code> (<code class="relevant marker">string-upcase</code> <var>place</var>))
  <var>place</var>)
=&gt; <code class="string">"YAY"</code></code></pre>
        </div>

        <div class="scroll">
          <pre class="example"><code class="common-lisp">;; "listf"?
(let ((<var>place</var> 'atom))
  (<code class="relevant">modify</code> (<code class="relevant marker">list</code> <var>place</var>))
  <var>place</var>)
=&gt; (ATOM)</code></pre>
        </div>

        <div class="scroll">
          <pre class="example"><code class="common-lisp">;; "class-off"?
(let ((<var>place</var> 'symbol))
  (<code class="relevant">modify</code> (<code class="relevant marker">class-of</code> <var>place</var>))
  <var>place</var>)
=&gt; #&lt;BUILT-IN-CLASS SYMBOL&gt;</code></pre>
        </div>

        <div class="scroll">
          <pre class="example"><code class="common-lisp">;; "parse-integerf"?
(let ((<var>place</var> <code class="string">"1986"</code>))
  (<code class="relevant">modify</code> (<code class="relevant marker">parse-integer</code> <var>place</var>))
  <var>place</var>)
=&gt; 1986</code></pre>
        </div>

      </section>

      <section id="why-not-by-hand">

        <h1 class="breadcrumbs-bar">
          <span class="section-relative-nav">
            <a href="#why-not-by-hand" class="anchor">⚓</a>
          </span>
          <span class="breadcrumbs">
            <a href="#">place-modifiers</a>
            <span class="crumb"><span class="s"> » </span><a class="here">Why not just write it out by hand?</a></span>
          </span>
        </h1>

        <p>One might wonder, why not just write this instead?</p>

        <div class="scroll">
          <pre class="example"><code class="common-lisp">(let ((<var>place</var> (list 1 2 3)))
  (setf <var>place</var> (nreverse <var>place</var>))
  <var>place</var>)
;; instead of
(let ((<var>place</var> (list 1 2 3)))
  (<code class="relevant">modify</code> (<code class="relevant marker">nreverse</code> <var>place</var>))
  <var>place</var>)</code></pre>
        </div>

        <p>(And forget about <code class="common-lisp">(nreverse (list 1 2 3))</code> or <code class="common-lisp">(list 3 2 1)</code> because that's missing the point. ;P) The answer is that "place" might of course be much longer-named and/or more complex than this. And of course, multiple evaluation of the place will be averted, which is important when side-effects and/or expensive accesses are involved.</p>

        <div class="scroll">
          <pre class="example"><code class="common-lisp">(let ((<var>my-list-of-three-elements</var> (list 1 2 3)))
  (<code class="relevant">modify</code> (<code class="relevant marker">nreverse</code> <var>my-list-of-three-elements</var>))
  <var>my-list-of-three-elements</var>)
==
(let ((<var>my-list-of-three-elements</var> (list 1 2 3)))
  (setf <var>my-list-of-three-elements</var> (nreverse <var>my-list-of-three-elements</var>))
  <var>my-list-of-three-elements</var>)</code></pre>
        </div>

        <div class="scroll">
          <pre class="example"><code class="common-lisp">(let ((<var>hash</var> (make-hash-table)))
  (setf (gethash 'key <var>hash</var>) 10)
  (<code class="relevant">modify</code> (<code class="relevant marker">/</code> (gethash (print 'key) <var>hash</var>) 5))
  (gethash 'key <var>hash</var>))
==
(let ((<var>hash</var> (make-hash-table)))
  (setf (gethash 'key <var>hash</var>) 10)
  (let ((key (print 'key)))
    (setf (gethash key <var>hash</var>) (/ (gethash key <var>hash</var>) 5)))
  (gethash 'key <var>hash</var>))
-| KEY
=&gt; 2, T</code></pre>
        </div>

      </section>

      <section id="modify-return-values">

        <h1 class="breadcrumbs-bar">
          <span class="section-relative-nav">
            <a href="#modify-return-values" class="anchor">⚓</a>
          </span>
          <span class="breadcrumbs">
            <a href="#">place-modifiers</a>
            <span class="crumb"><span class="s"> » </span><a class="here"><code class="relevant">modify</code> return values, <code class="relevant marker">:old</code></a></span>
          </span>
        </h1>

        <p><code class="relevant">modify</code> normally returns the new value(s) of the place, per the usual conventions:</p>

        <div class="scroll">
          <pre class="example"><code class="common-lisp">(let ((<var>place</var> 2))
  (values (<code class="relevant">modify</code> (<code class="relevant marker">expt</code> <var>place</var> 8))
          <var>place</var>))
=&gt; 256, 256</code></pre>
        </div>

        <p>But one simple yet very useful feature is to be able to return the old value instead:</p>

        <div class="scroll">
          <pre class="example"><code class="common-lisp">(let ((<var>place</var> 2))
  (values (<code class="relevant">modify</code> (<code class="relevant marker">:old</code> (<code class="relevant marker">expt</code> <var>place</var> 8)))
          <var>place</var>))
=&gt; 2, 256</code></pre>
        </div>

      </section>

      <section id="place-modification-expression-vs-place">

        <h1 class="breadcrumbs-bar">
          <span class="section-relative-nav">
            <a href="#place-modification-expression-vs-place" class="anchor">⚓</a>
          </span>
          <span class="breadcrumbs">
            <a href="#">place-modifiers</a>
            <span class="crumb"><span class="s"> » </span><a class="here"><abbr title="place-modification-expression">PME</abbr> VS place</a></span>
          </span>
        </h1>

        <nav class="tabs">
          <ul>
            <li><a href="#conservative-recursion-through-spots">Conservative recursion through "spots"</a></li>
            <li><a href="#inconceivable-places">Inconceivable places</a></li>
            <li><a href="#explicit-place">Speculative recursion through "spots" (<code class="relevant marker">:place</code>)</a></li>
            <li><a href="#top-level">Possible place at top-level: treated as <abbr title="place-modification-expression">PME</abbr></a></li>
          </ul>
        </nav>

        <p>Some place-modifiers are also valid places. One example is <code>aref</code>. In the following example, how does <code class="relevant">modify</code> know which of <code class="common-lisp">(aref <var>object</var> 0)</code> or <var>object</var> should be interpreted as being the place to modify?</p>

        <div class="scroll">
          <pre class="example"><code class="common-lisp">(let ((<var>object</var> (vector 'e)))
  (values (<code class="relevant">modify</code> (<code class="relevant marker">:old</code> (<code class="relevant marker">list</code> (aref <var>object</var> 0))))
          <var>object</var>))
=&gt; E, #((E))
or #(E), (E) ?</code></pre>
        </div>

        <section id="conservative-recursion-through-spots">

          <h1 class="breadcrumbs-bar">
            <span class="section-relative-nav">
              <a href="#conservative-recursion-through-spots" class="anchor">⚓</a>
            </span>
            <span class="breadcrumbs">
              <a href="#">place-modifiers</a>
              <span class="crumb"><span class="s"> » </span><a href="#place-modification-expression-vs-place"><abbr title="place-modification-expression">PME</abbr> VS place</a></span>
              <span class="crumb"><span class="s"> » </span><a class="here">Conservative recursion through "spots"</a></span>
            </span>
          </h1>

          <p>It's simple: <code class="relevant">modify</code> is "conservative" by default, so as soon as it encounters a possible place while recursing through the "spots" (described and explained below), then it will treat that as the place. This is the most intuitive possible default and is usually what you want.</p>

          <p>In the above example, <code class="common-lisp">(aref <var>object</var> 0)</code> is the place to modify, not <var>object</var>.</p>

        </section>

      <section id="inconceivable-places">

        <h1 class="breadcrumbs-bar">
          <span class="section-relative-nav">
            <a href="#inconceivable-places" class="anchor">⚓</a>
          </span>
          <span class="breadcrumbs">
            <a href="#">place-modifiers</a>
            <span class="crumb"><span class="s"> » </span><a href="#place-modification-expression-vs-place"><abbr title="place-modification-expression">PME</abbr> VS place</a></span>
            <span class="crumb"><span class="s"> » </span><a class="here">Inconceivable places</a></span>
          </span>
        </h1>

        <p>Some place-modifiers are known to <code class="relevant">modify</code> as being "inconceivable places", which allows conservative recursion to proceed (at least) one step further, much conveniently:</p>

        <div class="scroll">
          <pre class="example"><code class="common-lisp">(let ((<var>list</var> '((d . 4))))
  (values (<code class="relevant">modify</code> (<code class="relevant marker">:old</code> (<code class="relevant marker">cons</code> 'first (<code class="relevant marker">list*</code> 'a 1 'b 2 (<code class="relevant marker">acons</code> 'c 3 <var>list</var>)))))
          <var>list</var>))
=&gt; ((D . 4)), (FIRST A 1 B 2 (C . 3) (D . 4))</code></pre>
        </div>

      </section>

      <section id="explicit-place">

        <h1 class="breadcrumbs-bar">
          <span class="section-relative-nav">
            <a href="#explicit-place" class="anchor">⚓</a>
          </span>
          <span class="breadcrumbs">
            <a href="#">place-modifiers</a>
            <span class="crumb"><span class="s"> » </span><a href="#place-modification-expression-vs-place"><abbr title="place-modification-expression">PME</abbr> VS place</a></span>
            <span class="crumb"><span class="s"> » </span><a class="here">Speculative recursion through "spots" (<code class="relevant marker">:place</code>)</a></span>
          </span>
        </h1>

        <p>After finding the <a href="#conservative-recursion-through-spots">most conservative place</a>, <code class="relevant">modify</code> will still speculatively recurse through the remaining "spots" in search of a <code class="relevant marker">:place</code> "local special form", which would explicitly indicate at what level lies the intended place, overriding the conservative behavior.</p>

        <div class="scroll">
          <pre class="example"><code class="common-lisp">(let ((<var>object</var> (vector 'e)))
  (values (<code class="relevant">modify</code> (<code class="relevant marker">:old</code> (<code class="relevant marker">list</code> (<code class="relevant marker">aref</code> (<code class="relevant marker">:place</code> <var>object</var>) 0))))
          <var>object</var>))
=&gt; #(E), (E)</code></pre>
        </div>

      </section>

      <section id="top-level">

        <h1 class="breadcrumbs-bar">
          <span class="section-relative-nav">
            <a href="#top-level" class="anchor">⚓</a>
          </span>
          <span class="breadcrumbs">
            <a href="#">place-modifiers</a>
            <span class="crumb"><span class="s"> » </span><a href="#place-modification-expression-vs-place"><abbr title="place-modification-expression">PME</abbr> VS place</a></span>
            <span class="crumb"><span class="s"> » </span><a class="here">Possible place at top-level: treated as <abbr title="place-modification-expression">PME</abbr></a></span>
          </span>
        </h1>

        <p>Of course, the "top-level" (ignoring <code class="relevant marker">:old</code>) of <code class="relevant">modify</code> can only accept a <abbr title="place-modification-expression">PME</abbr> and not a place, so there can be no ambiguity there:</p>

        <div class="scroll">
          <pre class="example"><code class="common-lisp">(let ((<var>object</var> (vector 'e)))
  (values (<code class="relevant">modify</code> (<code class="relevant marker">:old</code> (<code class="relevant marker">aref</code> (<code class="relevant marker">:place</code> <var>object</var>) 0)))
          <var>object</var>))
=&gt; #(E), E</code></pre>
        </div>

      </section>

      </section>

      <section id="multiple-place-modification-expressions">

        <h1 class="breadcrumbs-bar">
          <span class="section-relative-nav">
            <a href="#multiple-place-modification-expressions" class="anchor">⚓</a>
          </span>
          <span class="breadcrumbs">
            <a href="#">place-modifiers</a>
            <span class="crumb"><span class="s"> » </span><a class="here">Multiple <abbr title="place-modification-expression">PME</abbr>s: <code>setf</code>-like</a></span>
          </span>
        </h1>

        <p><code class="relevant">modify</code> can accept multiple <abbr title="place-modification-expression">PME</abbr>s, in which case the modifications will happen in sequence, much in the same way as <code>setf</code> with multiple places.</p>

        <div class="scroll">
          <pre class="example"><code class="common-lisp">(let ((<var>x</var> 'a) (<var>y</var> 'b))
  (values (<code class="relevant">modify</code> (<code class="relevant marker">list</code> <var>x</var>)
                  (<code class="relevant marker">:old</code> (<code class="relevant marker">cons</code> <var>y</var> <var>x</var>)))
          <var>x</var>
          <var>y</var>))
==
(let ((<var>x</var> 'a) (<var>y</var> 'b))
  (values (progn (<code class="relevant">modify</code> (<code class="relevant marker">list</code> <var>x</var>))
                 (<code class="relevant">modify</code> (<code class="relevant marker">:old</code> (<code class="relevant marker">cons</code> <var>y</var> <var>x</var>))))
          <var>x</var>
          <var>y</var>))
=&gt; (A), (B A), B</code></pre>
        </div>

      </section>

      <section id="place-modifier-variants">

        <h1 class="breadcrumbs-bar">
          <span class="section-relative-nav">
            <a href="#place-modifier-variants" class="anchor">⚓</a>
          </span>
          <span class="breadcrumbs">
            <a href="#">place-modifiers</a>
            <span class="crumb"><span class="s"> » </span><a class="here">Place-modifier variants</a></span>
          </span>
        </h1>

        <p>Up to this point, we've always used the "primary variant", which is the one you'll need most often, but each place-modifier kind can have up to 4 variants, though most only have one or two. The "variant" determines which argument is treated as the "spot", positionally.</p>

        <p>The determination of which variant maps to which spot is made by the definer of the place-modifier.</p>

      </section>

      <section id="variants-statistics">

        <h1 class="breadcrumbs-bar">
          <span class="section-relative-nav">
            <a href="#variants-statistics" class="anchor">⚓</a>
          </span>
          <span class="breadcrumbs">
            <a href="#">place-modifiers</a>
            <span class="crumb"><span class="s"> » </span><a class="here">Some statistics about place-modifier variants</a></span>
          </span>
        </h1>

        <div class="scroll">
          <pre class="example"><code class="common-lisp">(let ((<var>variant-counts</var> (vector 0 0 0 0)))
  (<code class="relevant">place-modifiers:map-infos</code>
   (lambda (<var>name</var> <var>info</var>)
     (declare (ignore <var>name</var>))
     (<code class="relevant">modify</code> (<code class="relevant marker">1+</code> (aref <var>variant-counts</var>
                       (1- (length (<code class="relevant">place-modifiers:spot-indexes</code> <var>info</var>))))))))
  <var>variant-counts</var>)
=&gt; #(301 172 35 2)</code></pre>
        </div>

        <p>So as of version 2.1, there are 301 place-modifiers with one single variant, 172 with 2 variants, and only 37 with 3 or 4 variants.</p>

      </section>

    </main>

    <footer id="footer">
      <div class="back-to-top left">
        <a href="#">⬆</a>
      </div>
      <div class="main">
        <a href="https://validator.w3.org/check?uri=http%3A%2F%2Fwww.hexstreamsoft.com%2Flibraries%2Fplace-modifiers%2F">✔ HTML5</a>
        <a href="https://www.hexstreamsoft.com/README">✔ Public Domain</a>
        <a href="https://jigsaw.w3.org/css-validator/validator?uri=http%3A%2F%2Fwww.hexstreamsoft.com%2Flibraries%2Fplace-modifiers%2F">✔ CSS3</a>
        <a>✔ Mobile-friendly</a>
      </div>
      <div class="back-to-top right">
        <a href="#">⬆</a>
      </div>
    </footer>

  </body>
</html>
